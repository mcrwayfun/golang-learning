## go语言圣经

### 1 程序结构

#### 1-1 命名

一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

名字的开头字母的大小写决定了名字在包外的可见性，如果一个变量是大写的，那么它将是可导出的，这意味着可以在包外进行访问。

#### 1-2 声明

go程序由一个或者多个.go的源文件组成。每个源文件以包的声明开始（package），表明它是属于哪一个包。包声明语句之后是import语句导入依赖的其它包。然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要。

函数中，如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到renturn返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。

- Question1:如果函数存在返回值，但是没有return，编译器是否会报错？（肯定会）
- Question2:如果函数存在返回值，return时没有带上值（直接写个return），是否可行？（在返回值处声明变量，并给变量赋值）

#### 1-3 变量

##### 1-3-1 var

go使用var创建一个特定类型的变量，标准格式为：

```go
var 变量名字 类型 = 表达式
```

其中类型或者表达式可以省略。如果省略了类型，那么将根据表达式来推导变量的类型；如果省略了表达式，则会根据类型给予它一个零值。

数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

- Question1：函数体的返回值声明了变量，是否有初值？

这样做的好处是避免了频繁的校验，减少代码量。

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量

```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

- Question1：可以初始化和省略一起使用吗？比如 `var a,b = true,` 

##### 1-3-2 简短变量

有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“**名字 := 表达式**”形式声明变量，变量的类型根据表达式来自动推导

- Attention1：var常用于需要显示指定变量类型，简短变量命名用于初始化值。两者用法区别在于：是否具有初始值。
- Attention2：“:=” 和“ =” ，一个是变量声明，而另一个是赋值
- Attention3：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在**相同的词法域声**明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了
- Question1：词法域是什么？go中存在着什么作用域？
- Attention4：简短变量声明语句中必须至少要声明一个新的变量，否则将视为赋值操作，这将不能通过编译检查

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

##### 1-3-3 指针

指针的值可以认为是变量的内存地址。每一个变量都有对应的内存地址，而指针则对应变量在内存中存储的位置。

- Question1：基本变量类型是否也有对应的内存地址

假如现在有`var x int` , 那么使用&x表达式（取x变量的地址）将产生一个指向x变量的指针，指针对应的类型是 *int，被称为指向int类型的指针。

如果存在一个指针变量为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时`*p`表达式对应p指针指向的变量的值。一般`*p`表达式读取指针指向的变量的值，这里为int类型的值，

- Attention1：如果*后面带的是类型（基本类型或结构体等），那么可以认为该表达式是指针。如果 *后面带的是具体的变量名，那么就是获取该变量的值
- Attention2：即使是局部变量，其表达式也要接受&操作，即肯定会存在内存地址
- Attention3：聚合类型的每个成员，也对应着一个变量，可以使用&取值。若要判断聚合类型是否相等，则二者的每一个成员变量均需要相等

在Go语言中，**返回函数中局部变量的地址也是安全的**。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

```go
var p = f()

func f() *int {
    v := 1
    return &v
}
```

- Question2：是否只要存在着引用，这个变量的地址就不会被回收？go是如何进行垃圾回收的？

**指针特别有价值的地方在于我们可以不用名字而访问一个变量**，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名

##### 1-3-4 new函数

创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`。new函数类似是一种语法糖，而不是一个新的基础概念

```Go
new(int) 等同于 
var dummy int
&int
```

- Attention1：new不是一个关键字，只是一个预定义的函数，所以可以使用new作为变量名

##### 1-3-5 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，在局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

那么垃Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

- Question1：go逃逸

#### 1-4 赋值

##### 1-4-1 元组赋值

它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。可以利用这个特性交换元素（不通过中间变量）

#### 1-5 类型

```go
type 类型名字 底层类型
```

类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。

#### 1-6 包和文件

包的初始化首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始化。

```go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1
```

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

每个go文件中可以 包含一个或多个init函数，它会在源文件被初始化时自动执行。

- Question1：init和包级变量的初始化，常量的初始化哪一个更快？
- Question2：多个init函数的执行顺序
- Question3：init函数的通常作用

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。

- Tips：复杂的变量初始化，可以采用匿名函数的方式去处理

```go
// pc[i] is the population count of i.
var pc [256]byte = func() (pc [256]byte) {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
}()
```

#### 1-7 作用域

声明语句的作用域是指源代码中可以有效使用这个名字的范围。

当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。

```go
var cwd string

func init() {
    cwd, err := os.Getwd() // compile error: unused: cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```

虽然cwd在外部已经声明过，但是`:=`语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。

### 2 数据类型

#### 2-1 整型

Go语言提供了有符号和无符号的整数类型，分别有int8、int16、int32、int64，无符号的有uint8、uint16、uint32、uint64。与此同时，还有对应特定CPU机器大小的有符号和无符号整形int和uint。这两种类型都有同样的大小，32或64bit，根据编译平台可能会产生不同的大小。

Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。

Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。

在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此`-5%3`和`-5%-3`结果都是-2。除法运算符`/`的行为则依赖于操作数是否为全为整数，比如`5.0/4.0`的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。

对于整数，+x是0+x的简写，-x则是0-x的简写；对于浮点数和复数，+x就是x，-x则是x 的负数。

- Question1：浮点数和复数如何进行加减
- 无符号uint = 0时，减1的流程

```go
for i := len(medals) - 1; i >= 0; i-- {
    fmt.Println(medals[i]) // "bronze", "silver", "gold"
}
```

内置的len函数返回一个有符号的int，如果len函数返回一个无符号数，那么i也将是无符号的uint类型，然后条件`i >= 0`则永远为真。在三次迭代之后，也就是`i == 0`时，i--语句将不会产生-1，而是变成一个uint类型的最大值（可能是2^64-1264−1）

请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的`[1]`副词告诉Printf函数再次使用第一个操作数。第二，%后的`#`副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。

#### 2-2 浮点数

Go语言提供了两种精度的浮点数，float32和float64。

浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。

一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）

math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)

```go
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```

函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）

```go
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
```

#### 2-3 复数

Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```

#### 2-4 布尔型

因为`&&`的优先级比`||`高（助记：**`&&`对应逻辑乘法，`||`对应逻辑加法，乘法比加法优先级要高**）

#### 2-5 字符串

一个字符串是一个不可改变的字节序列

- Question1：不可改变体现在哪里？

字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列

第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节

子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。

```go
s := "hello, world"
fmt.Println(s[0:5]) // "hello"
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:])  // "hello, world"
```

其中+操作符将两个字符串链接构造一个新字符串。

```go
fmt.Println("goodbye" + s[5:]) // "goodbye, world"
```

字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。

- Question2：自然编码顺序是ASSII？

**字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变**，当然我们也可以给一个字符串变量分配一个新字符串值

因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的

```go
s[0] = 'L' // compile error: cannot assign to s[0]
```

一个原生的字符串面值形式是`...`，使用反引号`代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+"```"链接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统。

原生字符串面值用于编写正则表达式，HTML模板、JSON面值等。

```go
const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`
```

- Question3：Windows系统会把回车和换行一起放入文本文件中？？？是指go在不同系统中的使用原生字符串面值不一致？



