## go语言圣经

### 1 程序结构

#### 1-1 命名

一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

名字的开头字母的大小写决定了名字在包外的可见性，如果一个变量是大写的，那么它将是可导出的，这意味着可以在包外进行访问。

#### 1-2 声明

go程序由一个或者多个.go的源文件组成。每个源文件以包的声明开始（package），表明它是属于哪一个包。包声明语句之后是import语句导入依赖的其它包。然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要。

函数中，如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到renturn返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。

- Question1:如果函数存在返回值，但是没有return，编译器是否会报错？（肯定会）
- Question2:如果函数存在返回值，return时没有带上值（直接写个return），是否可行？（在返回值处声明变量，并给变量赋值）

#### 1-3 变量

##### 1-3-1 var

go使用var创建一个特定类型的变量，标准格式为：

```go
var 变量名字 类型 = 表达式
```

其中类型或者表达式可以省略。如果省略了类型，那么将根据表达式来推导变量的类型；如果省略了表达式，则会根据类型给予它一个零值。

数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

- Question1：函数体的返回值声明了变量，是否有初值？

这样做的好处是避免了频繁的校验，减少代码量。

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量

```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

- Question1：可以初始化和省略一起使用吗？比如 `var a,b = true,` 

##### 1-3-2 简短变量

有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“**名字 := 表达式**”形式声明变量，变量的类型根据表达式来自动推导

- Attention1：var常用于需要显示指定变量类型，简短变量命名用于初始化值。两者用法区别在于：是否具有初始值。
- Attention2：“:=” 和“ =” ，一个是变量声明，而另一个是赋值
- Attention3：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在**相同的词法域声**明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了
- Question1：词法域是什么？go中存在着什么作用域？
- Attention4：简短变量声明语句中必须至少要声明一个新的变量，否则将视为赋值操作，这将不能通过编译检查

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

##### 1-3-3 指针

指针的值可以认为是变量的内存地址。每一个变量都有对应的内存地址，而指针则对应变量在内存中存储的位置。

- Question1：基本变量类型是否也有对应的内存地址

假如现在有`var x int` , 那么使用&x表达式（取x变量的地址）将产生一个指向x变量的指针，指针对应的类型是 *int，被称为指向int类型的指针。

如果存在一个指针变量为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时`*p`表达式对应p指针指向的变量的值。一般`*p`表达式读取指针指向的变量的值，这里为int类型的值，

- Attention1：如果*后面带的是类型（基本类型或结构体等），那么可以认为该表达式是指针。如果 *后面带的是具体的变量名，那么就是获取该变量的值
- Attention2：即使是局部变量，其表达式也要接受&操作，即肯定会存在内存地址
- Attention3：聚合类型的每个成员，也对应着一个变量，可以使用&取值。若要判断聚合类型是否相等，则二者的每一个成员变量均需要相等

在Go语言中，**返回函数中局部变量的地址也是安全的**。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

```go
var p = f()

func f() *int {
    v := 1
    return &v
}
```

- Question2：是否只要存在着引用，这个变量的地址就不会被回收？go是如何进行垃圾回收的？

**指针特别有价值的地方在于我们可以不用名字而访问一个变量**，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名