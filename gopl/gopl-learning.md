## go语言圣经

### 1 程序结构

#### 1-1 命名

一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

名字的开头字母的大小写决定了名字在包外的可见性，如果一个变量是大写的，那么它将是可导出的，这意味着可以在包外进行访问。

#### 1-2 声明

go程序由一个或者多个.go的源文件组成。每个源文件以包的声明开始（package），表明它是属于哪一个包。包声明语句之后是import语句导入依赖的其它包。然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要。

函数中，如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到renturn返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。

- Question1:如果函数存在返回值，但是没有return，编译器是否会报错？（肯定会）
- Question2:如果函数存在返回值，return时没有带上值（直接写个return），是否可行？（在返回值处声明变量，并给变量赋值）

#### 1-3 变量

##### 1-3-1 var

go使用var创建一个特定类型的变量，标准格式为：

```go
var 变量名字 类型 = 表达式
```

其中类型或者表达式可以省略。如果省略了类型，那么将根据表达式来推导变量的类型；如果省略了表达式，则会根据类型给予它一个零值。

数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

- Question1：函数体的返回值声明了变量，是否有初值？

这样做的好处是避免了频繁的校验，减少代码量。

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量

```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

- Question1：可以初始化和省略一起使用吗？比如 `var a,b = true,` 

##### 1-3-2 简短变量

有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“**名字 := 表达式**”形式声明变量，变量的类型根据表达式来自动推导

- Attention1：var常用于需要显示指定变量类型，简短变量命名用于初始化值。两者用法区别在于：是否具有初始值。
- Attention2：“:=” 和“ =” ，一个是变量声明，而另一个是赋值
- Attention3：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在**相同的词法域声**明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了
- Question1：词法域是什么？go中存在着什么作用域？
- Attention4：简短变量声明语句中必须至少要声明一个新的变量，否则将视为赋值操作，这将不能通过编译检查

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

##### 1-3-3 指针

指针的值可以认为是变量的内存地址。每一个变量都有对应的内存地址，而指针则对应变量在内存中存储的位置。

- Question1：基本变量类型是否也有对应的内存地址

假如现在有`var x int` , 那么使用&x表达式（取x变量的地址）将产生一个指向x变量的指针，指针对应的类型是 *int，被称为指向int类型的指针。

如果存在一个指针变量为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时`*p`表达式对应p指针指向的变量的值。一般`*p`表达式读取指针指向的变量的值，这里为int类型的值，

- Attention1：如果*后面带的是类型（基本类型或结构体等），那么可以认为该表达式是指针。如果 *后面带的是具体的变量名，那么就是获取该变量的值
- Attention2：即使是局部变量，其表达式也要接受&操作，即肯定会存在内存地址
- Attention3：聚合类型的每个成员，也对应着一个变量，可以使用&取值。若要判断聚合类型是否相等，则二者的每一个成员变量均需要相等

在Go语言中，**返回函数中局部变量的地址也是安全的**。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

```go
var p = f()

func f() *int {
    v := 1
    return &v
}
```

- Question2：是否只要存在着引用，这个变量的地址就不会被回收？go是如何进行垃圾回收的？

**指针特别有价值的地方在于我们可以不用名字而访问一个变量**，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名

##### 1-3-4 new函数

创建变量的方法是调用用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`。new函数类似是一种语法糖，而不是一个新的基础概念

```Go
new(int) 等同于 
var dummy int
&int
```

- Attention1：new不是一个关键字，只是一个预定义的函数，所以可以使用new作为变量名

##### 1-3-5 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，在局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

那么垃Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

- Question1：go逃逸

#### 1-4 赋值

##### 1-4-1 元组赋值

它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。可以利用这个特性交换元素（不通过中间变量）

